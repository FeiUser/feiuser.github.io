<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;feiuser.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="第一章 BIO、NIO、AIO概述 第二章 Buffer类（缓冲区）(重点) 第三章 Channel（通道） 第四章 Selector(选择器) 第五章 NIO2-AIO(异步、非阻塞)  学习目标123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- 能够说出阻塞和非阻">
<meta property="og:type" content="article">
<meta property="og:title" content="NIO-AIO笔记">
<meta property="og:url" content="https://feiuser.github.io/2021/06/06/day13-NIO%E3%80%81AIO%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="LYF博客">
<meta property="og:description" content="第一章 BIO、NIO、AIO概述 第二章 Buffer类（缓冲区）(重点) 第三章 Channel（通道） 第四章 Selector(选择器) 第五章 NIO2-AIO(异步、非阻塞)  学习目标123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- 能够说出阻塞和非阻">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://feiuser.github.io/2021/06/06/day13-NIO%E3%80%81AIO%E7%AC%94%E8%AE%B0/img/1609290773294.png">
<meta property="og:image" content="https://feiuser.github.io/2021/06/06/day13-NIO%E3%80%81AIO%E7%AC%94%E8%AE%B0/img/11.png">
<meta property="og:image" content="https://feiuser.github.io/2021/06/06/day13-NIO%E3%80%81AIO%E7%AC%94%E8%AE%B0/img/12.png">
<meta property="og:image" content="https://feiuser.github.io/2021/06/06/day13-NIO%E3%80%81AIO%E7%AC%94%E8%AE%B0/img/1594870437329.png">
<meta property="og:image" content="https://feiuser.github.io/2021/06/06/day13-NIO%E3%80%81AIO%E7%AC%94%E8%AE%B0/img/1622447884036.png">
<meta property="article:published_time" content="2021-06-06T02:11:08.666Z">
<meta property="article:modified_time" content="2021-06-06T14:35:24.704Z">
<meta property="article:author" content="LYF">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://feiuser.github.io/2021/06/06/day13-NIO%E3%80%81AIO%E7%AC%94%E8%AE%B0/img/1609290773294.png">


<link rel="canonical" href="https://feiuser.github.io/2021/06/06/day13-NIO%E3%80%81AIO%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;feiuser.github.io&#x2F;2021&#x2F;06&#x2F;06&#x2F;day13-NIO%E3%80%81AIO%E7%AC%94%E8%AE%B0&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;06&#x2F;06&#x2F;day13-NIO、AIO笔记&#x2F;&quot;,&quot;title&quot;:&quot;NIO-AIO笔记&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>NIO-AIO笔记 | LYF博客</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="LYF博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LYF博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">2</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">2</span></a></li>
        <li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="nav-number">1.</span> <span class="nav-text">学习目标</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-BIO%E3%80%81NIO%E3%80%81AIO%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">第一章 BIO、NIO、AIO概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-BIO%E3%80%81NIO%E4%B8%8EAIO%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text">1.BIO、NIO与AIO概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E6%A6%82%E5%BF%B5-%E8%AE%B0%E4%BD%8F"><span class="nav-number">2.2.</span> <span class="nav-text">2.阻塞和非阻塞,同步和异步的概念(记住)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-Buffer%E7%B1%BB%EF%BC%88%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%89-%E9%87%8D%E7%82%B9"><span class="nav-number">3.</span> <span class="nav-text">第二章 Buffer类（缓冲区）(重点)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Buffer%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">1.Buffer概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BAByteBuffer"><span class="nav-number">3.2.</span> <span class="nav-text">2.创建ByteBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE-put"><span class="nav-number">3.3.</span> <span class="nav-text">3.添加数据-put</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%8E%B7%E5%8F%96-get"><span class="nav-number">3.4.</span> <span class="nav-text">3.获取-get</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AE%B9%E9%87%8F-capacity"><span class="nav-number">3.5.</span> <span class="nav-text">4.容量-capacity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%99%90%E5%88%B6-limit"><span class="nav-number">3.6.</span> <span class="nav-text">5.限制-limit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E4%BD%8D%E7%BD%AE-position"><span class="nav-number">3.7.</span> <span class="nav-text">6.位置-position</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E8%BF%98%E5%8E%9F-clear"><span class="nav-number">3.8.</span> <span class="nav-text">7.还原-clear</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%BC%A9%E5%B0%8F%E8%8C%83%E5%9B%B4-flip"><span class="nav-number">3.9.</span> <span class="nav-text">8.缩小范围-flip</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-Channel%EF%BC%88%E9%80%9A%E9%81%93%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">第三章 Channel（通道）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Channel%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">1.Channel概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-ServerSocketChannel%E5%92%8CSocketChannel%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5"><span class="nav-number">4.2.</span> <span class="nav-text">2.ServerSocketChannel和SocketChannel创建连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-ServlerSocketChannel%E5%92%8CSocketChannel%E6%94%B6%E5%8F%91%E4%BF%A1%E6%81%AF-%E9%87%8D%E7%82%B9"><span class="nav-number">4.3.</span> <span class="nav-text">3.ServlerSocketChannel和SocketChannel收发信息(重点)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-Selector-%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">第四章 Selector(选择器)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">1.多路复用的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%80%89%E6%8B%A9%E5%99%A8Selector-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E6%B3%A8%E5%86%8C"><span class="nav-number">5.2.</span> <span class="nav-text">2.选择器Selector_服务器端实现多路注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%80%89%E6%8B%A9%E5%99%A8Selector-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">3.选择器Selector_常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%80%89%E6%8B%A9%E5%99%A8Selector-%E5%A4%9A%E8%B7%AF%E4%BF%A1%E6%81%AF%E6%8E%A5%E6%94%B6"><span class="nav-number">5.4.</span> <span class="nav-text">4.选择器Selector_多路信息接收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Selector%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">5.5.</span> <span class="nav-text">5.Selector执行的流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-NIO2-AIO-%E5%BC%82%E6%AD%A5%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">6.</span> <span class="nav-text">第五章 NIO2-AIO(异步、非阻塞)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-AIO%E6%A6%82%E8%BF%B0"><span class="nav-number">6.1.</span> <span class="nav-text">1.AIO概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-AIO%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.2.</span> <span class="nav-text">2.AIO异步非阻塞连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-AIO%E5%BC%82%E6%AD%A5%E8%BF%9E%E6%8E%A5-%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E8%AF%BB%E5%86%99"><span class="nav-number">6.3.</span> <span class="nav-text">3. AIO异步连接:异步阻塞读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-AIO%E5%BC%82%E6%AD%A5%E8%BF%9E%E6%8E%A5-%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%AF%BB%E5%86%99"><span class="nav-number">6.4.</span> <span class="nav-text">4.AIO异步连接:异步非阻塞读写</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LYF</p>
  <div class="site-description" itemprop="description">LYF博客，不止于技术，更记录人生点滴感悟。</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Feiuser" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Feiuser" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:670385209@qq.com" title="E-Mail → mailto:670385209@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://localhost:4000/" title="http:&#x2F;&#x2F;localhost:4000" rel="noopener" target="_blank">Title</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
		<div class="wechat_OA">
			<span>欢迎关注我的公众号</span>
			<br>
			<!-- 这里添加你的二维码图片 -->
			<img src ="https://cdn.jsdelivr.net/gh/happy2h/PicPool_cdn/qrcode_for_gh_13e96145e8ee_344.jpg">
		</div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://feiuser.github.io/2021/06/06/day13-NIO%E3%80%81AIO%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LYF">
      <meta itemprop="description" content="LYF博客，不止于技术，更记录人生点滴感悟。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYF博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          NIO-AIO笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-06 10:11:08 / 修改时间：22:35:24" itemprop="dateCreated datePublished" datetime="2021-06-06T10:11:08+08:00">2021-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <span id="more"></span>

<blockquote>
<p>第一章 BIO、NIO、AIO概述</p>
<p>第二章 Buffer类（缓冲区）(重点)</p>
<p>第三章 Channel（通道）</p>
<p>第四章 Selector(选择器)</p>
<p>第五章 NIO2-AIO(异步、非阻塞)</p>
</blockquote>
<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- 能够说出阻塞和非阻塞的概念</span><br><span class="line">	阻塞:等待结果,什么事也不能做</span><br><span class="line">	非阻塞:可以做别的事情</span><br><span class="line">- 能够说出同步和异步的概念</span><br><span class="line">	同步:主动获取结果(轮询)</span><br><span class="line">	异步:等待对方通知结果(回调函数)</span><br><span class="line">- 能够创建和使用ByteBuffer</span><br><span class="line">	获取对象的方式:</span><br><span class="line">		- <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span>  capacity)</span>：使用一个“容量”来创建一个“间接字节缓存区”——程序的“堆”空间中创建。</span></span><br><span class="line"><span class="function">        - <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span>：使用一个“容量”来创建一个“直接字节缓存区”——系统内存。</span></span><br><span class="line"><span class="function">        - <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] byteArray)</span>：使用一个“<span class="keyword">byte</span>[]数组”创建一个“间接字节缓存区”。</span></span><br><span class="line"><span class="function">	成员方法:</span></span><br><span class="line"><span class="function">		向ByteBuffer添加数据</span></span><br><span class="line"><span class="function">        - <span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span>：向当前可用位置添加数据。</span></span><br><span class="line"><span class="function">        - <span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] byteArray)</span>：向当前可用位置添加一个<span class="keyword">byte</span>[]数组</span></span><br><span class="line"><span class="function">        - <span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] byteArray,<span class="keyword">int</span> offset,<span class="keyword">int</span> len)</span>：添加一个<span class="keyword">byte</span>[]数组的一部分</span></span><br><span class="line"><span class="function">	</span></span><br><span class="line"><span class="function">		- <span class="keyword">byte</span>[] <span class="title">array</span><span class="params">()</span>  获取缓冲区中包含的字节数组</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">		- <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> 返回此缓冲区的容量。</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">		- <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span>：获取此缓冲区的限制。</span></span><br><span class="line"><span class="function">        - <span class="keyword">public</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span>：设置此缓冲区的限制。</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">		- <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span>：获取当前可写入位置索引。</span></span><br><span class="line"><span class="function">		- <span class="keyword">public</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> p)</span>：更改当前可写入位置索引。</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">		- <span class="keyword">public</span> Buffer <span class="title">clear</span><span class="params">()</span>：还原缓冲区的状态。</span></span><br><span class="line"><span class="function">          - 将position设置为：0</span></span><br><span class="line"><span class="function">          - 将限制limit设置为容量capacity；</span></span><br><span class="line"><span class="function">        - <span class="keyword">public</span> Buffer <span class="title">flip</span><span class="params">()</span>：缩小limit的范围。 获取读取的有效数据0到position之间的数据</span></span><br><span class="line"><span class="function">          - 将limit设置为当前position位置；</span></span><br><span class="line"><span class="function">          - 将当前position位置设置为0；</span></span><br><span class="line"><span class="function">- 能够使用ServerSocketChannel和SocketChannel实现连接并收发信息</span></span><br><span class="line"><span class="function">	同步非阻塞连接<span class="params">(NIO)</span></span></span><br><span class="line"><span class="function">	ServlerSocketChannel和SocketChannel收发信息</span></span><br><span class="line"><span class="function">- 能够说出Selector选择器的作用</span></span><br><span class="line"><span class="function">	使用了多路复用，只需要一个线程就可以处理多个通道，</span></span><br><span class="line"><span class="function">	降低内存占用率，减少CPU切换时间，在高并发、高频段业务环境下有非常重要的优势</span></span><br><span class="line"><span class="function">- 能够使用Selector选择器</span></span><br><span class="line"><span class="function">	选择器Selector_多路信息接收</span></span><br><span class="line"><span class="function">- 能够说出AIO的特点</span></span><br><span class="line"><span class="function">	异步非阻塞IO</span></span><br><span class="line"><span class="function">	非阻塞:</span></span><br><span class="line"><span class="function">		服务器<span class="params">(accept)</span>不用等待客户端请求,可以继续做其他的事情</span></span><br><span class="line"><span class="function">		客户端connect不会等待连接服务器成功,可以继续做其他的事情</span></span><br><span class="line"><span class="function">	异步:</span></span><br><span class="line"><span class="function">		不用轮询获取监听客户端,有客户端请求服务器,会触发回调函数<span class="params">(CompletionHandler)</span>,来处理这个请求   </span></span><br></pre></td></tr></table></figure>

<h1 id="第一章-BIO、NIO、AIO概述"><a href="#第一章-BIO、NIO、AIO概述" class="headerlink" title="第一章 BIO、NIO、AIO概述"></a>第一章 BIO、NIO、AIO概述</h1><h2 id="1-BIO、NIO与AIO概述"><a href="#1-BIO、NIO与AIO概述" class="headerlink" title="1.BIO、NIO与AIO概述"></a>1.BIO、NIO与AIO概述</h2><p>1).BIO：Block(阻塞的) IO——我们之前学的。            【同步、阻塞】<br>2).NIO：Non-Block(非阻塞的(同步)IO——JDK1.4开始的。    【同步、非阻塞】<br>3).AIO：Asynchronous(异步-非阻塞)IO——JDK1.7开始    【异步、非阻塞】</p>
<h2 id="2-阻塞和非阻塞-同步和异步的概念-记住"><a href="#2-阻塞和非阻塞-同步和异步的概念-记住" class="headerlink" title="2.阻塞和非阻塞,同步和异步的概念(记住)"></a>2.阻塞和非阻塞,同步和异步的概念(记住)</h2><p>举个例子，比如我们去照相馆拍照，拍完照片之后，商家说需要30分钟左右才能洗出来照片</p>
<ul>
<li><p>同步+阻塞</p>
<p>这个时候如果我们一直在店里面啥都不干，一直等待商家把它洗完照片，这个过程就叫同步阻塞。</p>
</li>
<li><p>同步+非阻塞</p>
<p>当然大部分人很少这么干，更多的是大家拿起手机开始看电视，看一会就会问老板洗完没，老板说没洗完，然后我们接着看，再过一会接着问(<strong>轮询</strong>)，直到照片洗完，这个过程就叫同步非阻塞。</p>
</li>
<li><p>异步+阻塞</p>
<p>因为店里生意太好了，越来越多的人过来拍，店里面快没地方坐了，老板说你把你手机号留下，我一会洗好了就打电话告诉你过来取，然后你去外面找了一个长凳开始躺着睡觉等待老板打电话，啥不都干，这个过程就叫异步阻塞。</p>
</li>
<li><p>异步+非阻塞</p>
<p>当然实际情况是，大家可能会直接先去逛街或者吃饭做其他的活动，同时等待老板打电话,这样以来两不耽误，这个过程就叫异步非阻塞。</p>
</li>
</ul>
<p>总结</p>
<p>从上面的描述中我们其实能够看到阻塞和非阻塞通常是指客户端在发出请求后，在服务端处理这个请求的过程中，客户端本身是否直接挂起等待结果(<strong>阻塞</strong>)，还是继续做其他的任务(<strong>非阻塞</strong>)。<br>而异步和同步，则是对于请求结果的获取是客户端主动等待获取(<strong>同步</strong>)，还是由服务端来通知消息结果(<strong>异步</strong>)。<br>从这一点来看同步和阻塞其实描述的两个不同角度的事情，阻塞和非阻塞指的一个是客户端等待消息处理时的本身的状态，是挂起还是继续干别的。同步和异步指的对于消息结果的获取是客户端主动获取，还是由服务端间接推送。</p>
<p><strong>阻塞:等待结果,什么事都不能做</strong></p>
<p><strong>非阻塞:可以做别的事情</strong></p>
<p><strong>同步:主动获取结果</strong></p>
<p><strong>异步:等待通知结果</strong></p>
<p>NIO之所以是同步，是因为它的accept/read/write方法的内核I/O操作都会阻塞当前线程<br>首先，我们要先了解一下NIO的三个主要组成部分：Buffer（缓冲区）、Channel（通道）、Selector（选择器）</p>
<h1 id="第二章-Buffer类（缓冲区）-重点"><a href="#第二章-Buffer类（缓冲区）-重点" class="headerlink" title="第二章 Buffer类（缓冲区）(重点)"></a>第二章 Buffer类（缓冲区）(重点)</h1><h2 id="1-Buffer概述"><a href="#1-Buffer概述" class="headerlink" title="1.Buffer概述"></a>1.Buffer概述</h2><ul>
<li><p>java.nio.Buffer(抽象类)：用于特定原始类型(基本类型)的数据的容器。后期在会用Channel进行通信时，底层全部使用Buffer。</p>
</li>
<li><p>它的几个子类：<br>1.ByteBuffer：<strong>里面可以封装一个byte[]数组。</strong>【重点掌握】<br>2.ShortBuffer：里面可以封装一个short[]数组。<br>3.CharBuffer：里面可以封装一个char[]数组<br>4.IntBuffer：里面可以封装一个int[]数组。<br>5.LongBuffer：里面可以封装一个long[]数组。<br>6.FloatBuffer：里面可以封装一个float[]数组。<br>7.DoubleBuffer：里面可以封装一个double[]数组。</p>
<p>没有boolean类型对应的Buffer</p>
</li>
</ul>
<h2 id="2-创建ByteBuffer"><a href="#2-创建ByteBuffer" class="headerlink" title="2.创建ByteBuffer"></a>2.创建ByteBuffer</h2><ul>
<li>没有构造方法可以创建ByteBuffer，可以通过它的一些“静态方法”获取ByteBuffer对象。</li>
<li>常用三个静态方法：   new byte[10];  默认值 0,0,0…0<ul>
<li>public static ByteBuffer allocate(int  capacity)：使用一个“容量”来创建一个“间接字节缓存区”——程序的“堆”空间中创建。</li>
<li>public static ByteBuffer allocateDirect(int capacity)：使用一个“容量”来创建一个“直接字节缓存区”——系统内存。   {1,2,3,4,5}</li>
<li>public static ByteBuffer wrap(byte[] byteArray)：使用一个“byte[]数组”创建一个“间接字节缓存区”。</li>
</ul>
</li>
<li>代码演示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建ByteBuffer</span></span><br><span class="line"><span class="comment">    - 没有构造方法可以创建ByteBuffer，可以通过它的一些“静态方法”获取ByteBuffer对象。</span></span><br><span class="line"><span class="comment">    - 常用三个静态方法：   new byte[10];  默认值 0,0,0...0</span></span><br><span class="line"><span class="comment">      - public static ByteBuffer allocate(int  capacity)：使用一个“容量”来创建一个“间接字节缓存区”——程序的“堆”空间中创建。</span></span><br><span class="line"><span class="comment">      - public static ByteBuffer allocateDirect(int capacity)：使用一个“容量”来创建一个“直接字节缓存区”——系统内存。   &#123;1,2,3,4,5&#125;</span></span><br><span class="line"><span class="comment">      - public static ByteBuffer wrap(byte[] byteArray)：使用一个“byte[]数组”创建一个“间接字节缓存区”。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ByteBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">10</span>);<span class="comment">//包含 byte数组[0,0,0,...0] 间接字节缓冲区==&gt;堆</span></span><br><span class="line">        System.out.println(buffer1);<span class="comment">//java.nio.HeapByteBuffer[pos=0 lim=10 cap=10]</span></span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer2 = ByteBuffer.allocateDirect(<span class="number">10</span>);<span class="comment">//包含 byte数组[0,0,0,...0] 直接字节缓冲区==&gt;系统</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="string">&quot;你好&quot;</span>.getBytes();</span><br><span class="line">        System.out.println(Arrays.toString(bytes));<span class="comment">//[-28, -67, -96, -27, -91, -67]</span></span><br><span class="line">        ByteBuffer buffer3 = ByteBuffer.wrap(bytes);<span class="comment">//包含byte数组[-28, -67, -96, -27, -91, -67] 间接字节缓冲区==&gt;堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-添加数据-put"><a href="#3-添加数据-put" class="headerlink" title="3.添加数据-put"></a>3.添加数据-put</h2><ul>
<li>public ByteBuffer put(byte b)：向当前可用位置添加数据。</li>
<li>public ByteBuffer put(byte[] byteArray)：向当前可用位置添加一个byte[]数组</li>
<li>public ByteBuffer put(byte[] byteArray,int offset,int len)：添加一个byte[]数组的一部分</li>
<li>byte[] array()获取此缓冲区的 byte 数组 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    添加数据-put</span></span><br><span class="line"><span class="comment">    - public ByteBuffer put(byte b)：向当前可用位置添加数据。</span></span><br><span class="line"><span class="comment">    - public ByteBuffer put(byte[] byteArray)：向当前可用位置添加一个byte[]数组</span></span><br><span class="line"><span class="comment">    - public ByteBuffer put(byte[] byteArray,int offset,int len)：添加一个byte[]数组的一部分</span></span><br><span class="line"><span class="comment">    - byte[] array()获取此缓冲区的 byte 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02put</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个长度为10的ByteBuffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//取出ByteBuffer对象内部存储的byte数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] arr = buffer.array();</span><br><span class="line">        System.out.println(Arrays.toString(arr));<span class="comment">//[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//public ByteBuffer put(byte b)：向当前可用位置添加数据。</span></span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">10</span>);</span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">20</span>);</span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">30</span>);</span><br><span class="line">        System.out.println(Arrays.toString(buffer.array()));<span class="comment">//[10, 20, 30, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//- public ByteBuffer put(byte[] byteArray)：向当前可用位置添加一个byte[]数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = &#123;<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>&#125;;</span><br><span class="line">        buffer.put(bytes);</span><br><span class="line">        System.out.println(Arrays.toString(buffer.array()));<span class="comment">//[10, 20, 30, 21, 22, 23, 24, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public ByteBuffer put(byte[] byteArray,int offset,int len)：添加一个byte[]数组的一部分</span></span><br><span class="line"><span class="comment">            int offset:开始索引</span></span><br><span class="line"><span class="comment">            int len:添加个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        buffer.put(bytes,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(Arrays.toString(buffer.array()));<span class="comment">//[10, 20, 30, 21, 22, 23, 24, 22, 23, 0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="img/1609290773294.png" alt="1609290773294"></p>
<h2 id="3-获取-get"><a href="#3-获取-get" class="headerlink" title="3.获取-get"></a>3.获取-get</h2><ul>
<li> get(int index): 获取缓冲区中的元素</li>
<li>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取-get</span></span><br><span class="line"><span class="comment">        - get(int index): 获取缓冲区中的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03get</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ByteBuffer对象</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//往ByteBuffer中添加数据</span></span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">10</span>);</span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">20</span>);</span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">30</span>);                           <span class="comment">//索引 0    1  2  3                  9</span></span><br><span class="line">        System.out.println(Arrays.toString(buffer.array()));<span class="comment">//[10, 20, 30, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(buffer.get(<span class="number">1</span>));<span class="comment">//20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-容量-capacity"><a href="#4-容量-capacity" class="headerlink" title="4.容量-capacity"></a>4.容量-capacity</h2><ul>
<li>Buffer的容量(capacity)是指：Buffer所能够包含的元素的最大数量。定义了Buffer后，容量是不可变的。</li>
<li>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    容量-capacity</span></span><br><span class="line"><span class="comment">        - Buffer的容量(capacity)是指：Buffer所能够包含的元素的最大数量。定义了Buffer后，容量是不可变的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04capacity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容量:&quot;</span>+buffer1.capacity());<span class="comment">//容量:10</span></span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer2 = ByteBuffer.wrap(<span class="string">&quot;你好吗&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;容量:&quot;</span>+buffer2.capacity());<span class="comment">//容量:9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-限制-limit"><a href="#5-限制-limit" class="headerlink" title="5.限制-limit"></a>5.限制-limit</h2><ul>
<li>限制：limit：表示如果设置“限制为某一个位置，那么此位置后的位置将不可用”。</li>
<li>有两个相关方法：<ul>
<li>public int limit()：获取此缓冲区的限制。</li>
<li>public Buffer limit(int newLimit)：设置此缓冲区的限制。</li>
</ul>
</li>
<li>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    限制-limit</span></span><br><span class="line"><span class="comment">    - 限制：limit：表示如果设置“限制为某一个位置，那么此位置后的位置将不可用”。</span></span><br><span class="line"><span class="comment">    - 有两个相关方法：</span></span><br><span class="line"><span class="comment">      - public int limit()：获取此缓冲区的限制。</span></span><br><span class="line"><span class="comment">      - public Buffer limit(int newLimit)：设置此缓冲区的限制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05limit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容量:&quot;</span>+buffer1.capacity()+<span class="string">&quot;,限定:&quot;</span>+buffer1.limit());<span class="comment">//容量:10,限定:10</span></span><br><span class="line"></span><br><span class="line">        buffer1.limit(<span class="number">3</span>);<span class="comment">//限定3和3以后的索引不能在使用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;容量:&quot;</span>+buffer1.capacity()+<span class="string">&quot;,限定:&quot;</span>+buffer1.limit());<span class="comment">//容量:10,限定:3</span></span><br><span class="line"></span><br><span class="line">        buffer1.put((<span class="keyword">byte</span>)<span class="number">10</span>);<span class="comment">//index:0</span></span><br><span class="line">        buffer1.put((<span class="keyword">byte</span>)<span class="number">20</span>);<span class="comment">//index:1</span></span><br><span class="line">        buffer1.put((<span class="keyword">byte</span>)<span class="number">30</span>);<span class="comment">//index:2</span></span><br><span class="line">        <span class="comment">//buffer1.put((byte)40);//index:3 BufferOverflowException:超出缓冲范围异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-位置-position"><a href="#6-位置-position" class="headerlink" title="6.位置-position"></a>6.位置-position</h2><ul>
<li>位置position是指：当前可写入的索引。位置不能小于0，并且不能大于”限制”。</li>
<li>有两个相关方法：<ul>
<li>public int position()：获取当前可写入位置索引。</li>
<li>public Buffer position(int p)：更改当前可写入位置索引。</li>
</ul>
</li>
<li>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    位置-position</span></span><br><span class="line"><span class="comment">    - 位置position是指：当前可写入的索引。位置不能小于0，并且不能大于&quot;限制&quot;。</span></span><br><span class="line"><span class="comment">    - 有两个相关方法：</span></span><br><span class="line"><span class="comment">      - public int position()：获取当前可写入位置索引。</span></span><br><span class="line"><span class="comment">      - public Buffer position(int p)：更改当前可写入位置索引。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06position</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> p1 = buffer.position();</span><br><span class="line">        System.out.println(<span class="string">&quot;p1:&quot;</span>+p1);<span class="comment">//p1:0</span></span><br><span class="line"></span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">10</span>);<span class="comment">//position=0</span></span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">20</span>);<span class="comment">//position=1</span></span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">30</span>);<span class="comment">//position=2</span></span><br><span class="line">        System.out.println(buffer.position());<span class="comment">//3</span></span><br><span class="line">        System.out.println(Arrays.toString(buffer.array()));<span class="comment">//[10, 20, 30, (p)0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//更改当前索引的位置</span></span><br><span class="line">        buffer.position(<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(buffer.array()));<span class="comment">//[10, (p)20, 30, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">100</span>);</span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">101</span>);</span><br><span class="line">        System.out.println(Arrays.toString(buffer.array()));<span class="comment">//[10, 100, 101, (p)0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-还原-clear"><a href="#7-还原-clear" class="headerlink" title="7.还原-clear"></a>7.还原-clear</h2><ul>
<li>public Buffer **clear()**：还原缓冲区的状态。<ul>
<li>将position设置为：0</li>
<li>将限制limit设置为容量capacity；</li>
</ul>
</li>
<li>示例代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    还原-clear</span></span><br><span class="line"><span class="comment">    - public Buffer clear()：还原缓冲区的状态。</span></span><br><span class="line"><span class="comment">      - 将position设置为：0</span></span><br><span class="line"><span class="comment">      - 将限制limit设置为容量capacity；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07clear</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">10</span>);<span class="comment">//position=0</span></span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">20</span>);<span class="comment">//position=1</span></span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">30</span>);<span class="comment">//position=2</span></span><br><span class="line"></span><br><span class="line">        buffer.limit(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;clear前==&gt;限制:&quot;</span>+buffer.limit()+<span class="string">&quot;,位置:&quot;</span>+buffer.position());<span class="comment">//clear前==&gt;限制:5,位置:3</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;clear后==&gt;限制:&quot;</span>+buffer.limit()+<span class="string">&quot;,位置:&quot;</span>+buffer.position());<span class="comment">//clear前==&gt;限制:10,位置:0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-缩小范围-flip"><a href="#8-缩小范围-flip" class="headerlink" title="8.缩小范围-flip"></a>8.缩小范围-flip</h2><ul>
<li>public Buffer **flip()**：缩小limit的范围。 <strong>获取读取的有效数据0到position之间的数据</strong><ul>
<li>将limit设置为当前position位置； [0, 1, 2, 0, 0, 0, 0, 0, 0, 0]  position=3 limit=10</li>
<li>将当前position位置设置为0；   position=0 limit=3  new String(bytes,0,len)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    缩小范围-flip</span></span><br><span class="line"><span class="comment">    - public Buffer flip()：缩小limit的范围。 获取读取的有效数据0到position之间的数据</span></span><br><span class="line"><span class="comment">      - 将limit设置为当前position位置； [0, 1, 2, 0, 0, 0, 0, 0, 0, 0]  position=3 limit=10</span></span><br><span class="line"><span class="comment">      - 将当前position位置设置为0；   position=0 limit=3  new String(bytes,0,len)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08flip</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">10</span>);<span class="comment">//position=0</span></span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">20</span>);<span class="comment">//position=1</span></span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">30</span>);<span class="comment">//position=2</span></span><br><span class="line">        System.out.println(Arrays.toString(buffer.array()));<span class="comment">//[10, 20, 30, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;flip前==&gt;限制:&quot;</span>+buffer.limit()+<span class="string">&quot;,位置:&quot;</span>+buffer.position());<span class="comment">//clear前==&gt;限制:10,位置:3</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="string">&quot;flip后==&gt;限制:&quot;</span>+buffer.limit()+<span class="string">&quot;,位置:&quot;</span>+buffer.position());<span class="comment">//clear前==&gt;限制:3,位置:0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第三章-Channel（通道）"><a href="#第三章-Channel（通道）" class="headerlink" title="第三章 Channel（通道）"></a>第三章 Channel（通道）</h1><h2 id="1-Channel概述"><a href="#1-Channel概述" class="headerlink" title="1.Channel概述"></a>1.Channel概述</h2><p>1).java.nio.channels.Channel(接口)：用于 I/O 操作的连接。 </p>
<ul>
<li>Channel表示：通道。</li>
<li>可以是“文件通道-FileChannel”、“网络通道-SocketChannel和ServerSockecChannel”。</li>
<li>它类似于IO流，但比IO流更强大。read(byte[])  write(byte[])</li>
<li>IO流是“单向”的，Channel是“双向的”。</li>
</ul>
<p>2).Channel全部使用Buffer实现读、写。read(ByteBuffer)  write(ByteBuffer)</p>
<h2 id="2-ServerSocketChannel和SocketChannel创建连接"><a href="#2-ServerSocketChannel和SocketChannel创建连接" class="headerlink" title="2.ServerSocketChannel和SocketChannel创建连接"></a>2.ServerSocketChannel和SocketChannel创建连接</h2><p><strong>同步阻塞实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>实现同步阻塞的服务器</span><br><span class="line">相关的类:</span><br><span class="line">	java.nio.channels.ServerSocketChannel:用于面向流的侦听套接字的可选通道。</span><br><span class="line">获取对象的方式:使用静态方法<span class="function">open</span></span><br><span class="line"><span class="function">	<span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span> 打开服务器插槽通道。</span></span><br><span class="line"><span class="function">成员方法:</span></span><br><span class="line"><span class="function">	ServerSocketChannel bind​<span class="params">(SocketAddress local)</span> 给服务器绑定指定的端口号,直接new</span></span><br><span class="line"><span class="function">	SocketChannel accept​<span class="params">()</span> 监听客户端的请求</span></span><br><span class="line"><span class="function">	SelectableChannel configureBlocking​<span class="params">(<span class="keyword">boolean</span> block)</span> 设置服务器的阻塞模式 <span class="keyword">true</span>:阻塞  <span class="keyword">false</span>:非阻塞,不写默认是阻塞的</span></span><br><span class="line"><span class="function">2.实现同步阻塞的客户端</span></span><br><span class="line"><span class="function">    相关的类:</span></span><br><span class="line"><span class="function">        java.nio.channels.SocketChannel:用于面向流的连接插座的可选通道。</span></span><br><span class="line"><span class="function">    获取对象的方法:使用静态方法open</span></span><br><span class="line"><span class="function">        <span class="keyword">static</span> SocketChannel open​<span class="params">()</span> 打开套接字通道。</span></span><br><span class="line"><span class="function">    成员方法:</span></span><br><span class="line"><span class="function">        <span class="keyword">boolean</span> connect​<span class="params">(SocketAddress remote)</span> 根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line"><span class="function">            参数:</span></span><br><span class="line"><span class="function">                SocketAddress remote:封装服务器的ip地址和端口号,用的时候直接new</span></span><br><span class="line"><span class="function">            返回值:<span class="keyword">boolean</span></span></span><br><span class="line"><span class="function">                连接服务器成功:<span class="keyword">true</span></span></span><br><span class="line"><span class="function">                连接服务器失败:<span class="keyword">false</span>,或者抛出连接异常</span></span><br><span class="line"><span class="function">        SelectableChannel configureBlocking​<span class="params">(<span class="keyword">boolean</span> block)</span> 设置客户端的阻塞模式</span></span><br><span class="line"><span class="function">            <span class="keyword">true</span>:阻塞<span class="params">(不写默认)</span> <span class="keyword">false</span>:非阻塞	</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo02NIOTCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    NIO:同步(主动获取)非阻塞(可以做其他的事情)的IO流</span></span><br><span class="line"><span class="comment">    创建NIO的服务器端</span></span><br><span class="line"><span class="comment">        1.使用ServerSocketChannel类中的方法open,获取服务器ServerSocketChannel对象</span></span><br><span class="line"><span class="comment">        2.使用ServerSocketChannel对象中的方法bind,给服务器绑定指定的端口号</span></span><br><span class="line"><span class="comment">        3.使用ServerSocketChannel对象中的方法accpet,监听并获取客户端SocketChannel对象</span></span><br><span class="line"><span class="comment">        4.释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOTCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用ServerSocketChannel类中的方法open,获取服务器ServerSocketChannel对象</span></span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.使用ServerSocketChannel对象中的方法bind,给服务器绑定指定的端口号</span></span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        <span class="comment">//3.使用ServerSocketChannel对象中的方法accpet,监听并获取客户端SocketChannel对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器已经启动,等待客户端连接...&quot;</span>);</span><br><span class="line">        SocketChannel socket = server.accept();<span class="comment">//accept方法,默认是阻塞的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;有客户端连接服务器....&quot;</span>);</span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo02NIOTCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建同步非阻塞客户端</span></span><br><span class="line"><span class="comment">    实现步骤</span></span><br><span class="line"><span class="comment">        1.使用SocketChannel类中的静态方法open,获取客户端SocketChannel对象</span></span><br><span class="line"><span class="comment">        2.使用SocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line"><span class="comment">        3.释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOTCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用SocketChannel类中的静态方法open,获取客户端SocketChannel对象</span></span><br><span class="line">        SocketChannel socket = SocketChannel.open();</span><br><span class="line">        <span class="comment">//2.使用SocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line">        <span class="keyword">boolean</span> b = socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务器同步非阻塞实现</strong>:服务器轮询监听客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo03NIOTCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    NIO:同步(主动获取)非阻塞(可以做其他的事情)的IO流</span></span><br><span class="line"><span class="comment">    创建NIO的服务器端</span></span><br><span class="line"><span class="comment">    实现非阻塞的服务器:</span></span><br><span class="line"><span class="comment">        SelectableChannel configureBlocking​(boolean block)</span></span><br><span class="line"><span class="comment">            设置服务器的阻塞模式 true:阻塞(不写)  false:非阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOTCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用ServerSocketChannel类中的方法open,获取服务器ServerSocketChannel对象</span></span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.使用ServerSocketChannel对象中的方法bind,给服务器绑定指定的端口号</span></span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现非阻塞的服务器</span></span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加一个死循环,轮询监听客户端的请求</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3.使用ServerSocketChannel对象中的方法accpet,监听并获取客户端SocketChannel对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已经启动,等待客户端连接...&quot;</span>);</span><br><span class="line">            SocketChannel socket = server.accept();<span class="comment">//accept方法,默认是阻塞的方法</span></span><br><span class="line">            <span class="comment">//增加一个判断,判断socket是否为null,不是null说明有客户端连接服务器</span></span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;有客户端连接服务器....结束轮询&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//4.释放资源</span></span><br><span class="line">                <span class="comment">//socket.close();</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//没有获取到客户端对象,睡眠2秒钟(干点其他事情),继续轮询,获取客户端对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;没有客户端请求服务器,睡眠2秒钟,再次轮询请求服务器...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//server.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">服务器已经启动,等待客户端连接...</span><br><span class="line">没有客户端请求服务器,睡眠<span class="number">2</span>秒钟,再次轮询请求服务器...</span><br><span class="line">服务器已经启动,等待客户端连接...</span><br><span class="line">没有客户端请求服务器,睡眠<span class="number">2</span>秒钟,再次轮询请求服务器...</span><br><span class="line">服务器已经启动,等待客户端连接...</span><br><span class="line">没有客户端请求服务器,睡眠<span class="number">2</span>秒钟,再次轮询请求服务器...</span><br><span class="line">服务器已经启动,等待客户端连接...</span><br><span class="line">没有客户端请求服务器,睡眠<span class="number">2</span>秒钟,再次轮询请求服务器...</span><br><span class="line">服务器已经启动,等待客户端连接...</span><br><span class="line">有客户端连接服务器....结束轮询</span><br></pre></td></tr></table></figure>

<p><strong>客户端轮询连接服务器:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo03NIOTCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建同步非阻塞客户端</span></span><br><span class="line"><span class="comment">    客户端实现非阻塞的客户端</span></span><br><span class="line"><span class="comment">    SelectableChannel configureBlocking​(boolean block) 设置客户端的阻塞模式</span></span><br><span class="line"><span class="comment">    true:阻塞(不写默认)</span></span><br><span class="line"><span class="comment">        connect:连接服务器成功,返回true</span></span><br><span class="line"><span class="comment">        connect:连接服务器失败,抛出连接异常</span></span><br><span class="line"><span class="comment">    false:非阻塞</span></span><br><span class="line"><span class="comment">        connect:连接服务器成功,返回false</span></span><br><span class="line"><span class="comment">        connect:连接服务器失败,返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOTCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个死循环,让客户端轮询连接服务器</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.使用SocketChannel类中的静态方法open,获取客户端SocketChannel对象</span></span><br><span class="line">                SocketChannel socket = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置客户端的阻塞模式</span></span><br><span class="line">                <span class="comment">//socket.configureBlocking(false);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//2.使用SocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line">                <span class="keyword">boolean</span> b = socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">                System.out.println(b);</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端连接服务器成功,结束轮询...&quot;</span>);</span><br><span class="line">                <span class="comment">//3.释放资源</span></span><br><span class="line">                socket.close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接服务器失败,睡眠2秒钟(干点其他事情),再次轮询连接服务器...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">连接服务器失败,睡眠<span class="number">2</span>秒钟(干点其他事情),再次轮询连接服务器...</span><br><span class="line">连接服务器失败,睡眠<span class="number">2</span>秒钟(干点其他事情),再次轮询连接服务器...</span><br><span class="line">连接服务器失败,睡眠<span class="number">2</span>秒钟(干点其他事情),再次轮询连接服务器...</span><br><span class="line">连接服务器失败,睡眠<span class="number">2</span>秒钟(干点其他事情),再次轮询连接服务器...</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">客户端连接服务器成功,结束轮询...</span><br></pre></td></tr></table></figure>

<h2 id="3-ServlerSocketChannel和SocketChannel收发信息-重点"><a href="#3-ServlerSocketChannel和SocketChannel收发信息-重点" class="headerlink" title="3.ServlerSocketChannel和SocketChannel收发信息(重点)"></a>3.ServlerSocketChannel和SocketChannel收发信息(重点)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo04NIOTCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用客户端给服务器发送数据,读取服务器回写的数据</span></span><br><span class="line"><span class="comment">    使用SocketChannel对象中的方法:</span></span><br><span class="line"><span class="comment">        int write(ByteBuffer src) 客户端给服务器发送数据</span></span><br><span class="line"><span class="comment">        int read(ByteBuffer dst)  读取服务器回写的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOTCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个死循环,让客户端轮询连接服务器</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.使用SocketChannel类中的静态方法open,获取客户端SocketChannel对象</span></span><br><span class="line">                SocketChannel socket = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//2.使用SocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line">                <span class="keyword">boolean</span> b = socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">                System.out.println(b);</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端连接服务器成功,客户端给服务器发送数据...&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;①客户端发送:你好服务器!&quot;</span>);</span><br><span class="line">                <span class="comment">//int write(ByteBuffer src) 客户端给服务器发送数据</span></span><br><span class="line">                socket.write(ByteBuffer.wrap(<span class="string">&quot;你好服务器!&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//int read(ByteBuffer dst)  读取服务器回写的数据</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">int</span> len = socket.read(buffer);</span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>,len);</span><br><span class="line">                System.out.println(<span class="string">&quot;④客户端读取服务器发送的数据:&quot;</span>+msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//3.释放资源</span></span><br><span class="line">                socket.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端读取完毕服务器发送的数据,结束轮询...&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接服务器失败,睡眠2秒钟(干点其他事情),再次轮询连接服务器...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo04NIOTCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    服务器读取客户端发送的数据,给客户端回写数据</span></span><br><span class="line"><span class="comment">    使用SocketChannel对象中的方法:</span></span><br><span class="line"><span class="comment">        int read(ByteBuffer dst)  读取客户端发送的数据</span></span><br><span class="line"><span class="comment">        int write(ByteBuffer src) 给客户端回写数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOTCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用ServerSocketChannel类中的方法open,获取服务器ServerSocketChannel对象</span></span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.使用ServerSocketChannel对象中的方法bind,给服务器绑定指定的端口号</span></span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现非阻塞的服务器</span></span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加一个死循环,轮询监听客户端的请求</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//3.使用ServerSocketChannel对象中的方法accpet,监听并获取客户端SocketChannel对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已经启动,等待客户端连接...&quot;</span>);</span><br><span class="line">            SocketChannel socket = server.accept();<span class="comment">//accept方法,默认是阻塞的方法</span></span><br><span class="line">            <span class="comment">//增加一个判断,判断socket是否为null,不是null说明有客户端连接服务器</span></span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;有客户端连接服务器....读取客户端发送的的数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//int read(ByteBuffer dst)  读取客户端发送的数据</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">int</span> len = socket.read(buffer);</span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>,len);</span><br><span class="line">                System.out.println(<span class="string">&quot;②服务器读取到客户端发送的数据:&quot;</span>+msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//int write(ByteBuffer src) 给客户端回写数据</span></span><br><span class="line">                System.out.println(<span class="string">&quot;③服务器给客户端回写:收到谢谢!&quot;</span>);</span><br><span class="line">                socket.write(ByteBuffer.wrap(<span class="string">&quot;收到,谢谢!&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//4.释放资源</span></span><br><span class="line">                socket.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器给客户端回写完数据,结束轮询....&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//没有获取到客户端对象,睡眠2秒钟(干点其他事情),继续轮询,获取客户端对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;没有客户端请求服务器,睡眠2秒钟,再次轮询请求服务器...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第四章-Selector-选择器"><a href="#第四章-Selector-选择器" class="headerlink" title="第四章 Selector(选择器)"></a>第四章 Selector(选择器)</h1><h2 id="1-多路复用的概念"><a href="#1-多路复用的概念" class="headerlink" title="1.多路复用的概念"></a>1.多路复用的概念</h2><p>选择器Selector是NIO中的重要技术之一。它与SelectableChannel联合使用实现了非阻塞的多路复用。使用它可以节省CPU资源，提高程序的运行效率。</p>
<p><strong>“多路”是指：服务器端同时监听多个“端口”的情况。每个端口都要监听多个客户端的连接。</strong></p>
<ul>
<li><p>服务器端的非多路复用效果</p>
<p><img src="img/11.png"></p>
<p><strong>如果不使用“多路复用”，服务器端需要开很多线程处理每个端口的请求。如果在高并发环境下，造成系统性能下降。</strong></p>
</li>
<li><p>服务器端的多路复用效果</p>
<p><img src="img/12.png"></p>
<p><strong>使用了多路复用，只需要一个线程就可以处理多个通道，降低内存占用率，减少CPU切换时间，在高并发、高频段业务环境下有非常重要的优势</strong></p>
</li>
</ul>
<h2 id="2-选择器Selector-服务器端实现多路注册"><a href="#2-选择器Selector-服务器端实现多路注册" class="headerlink" title="2.选择器Selector_服务器端实现多路注册"></a>2.选择器Selector_服务器端实现多路注册</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    选择器Selector_服务器端实现多路注册</span></span><br><span class="line"><span class="comment">    相关的类:</span></span><br><span class="line"><span class="comment">        java.nio.channels.Selector:SelectableChannel 对象的多路复用器。</span></span><br><span class="line"><span class="comment">    获取对象的方式:</span></span><br><span class="line"><span class="comment">        static Selector open() 打开一个选择器。</span></span><br><span class="line"><span class="comment">    把服务器注册到Selector选择器上:可以使用服务器ServerSocketChannel中的方法</span></span><br><span class="line"><span class="comment">        SelectionKey register(Selector sel, int ops) 向给定的选择器注册此通道(服务器)，返回一个选择键。</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">             Selector sel:传递选择器Selector对象</span></span><br><span class="line"><span class="comment">             int ops:要注册到选择器上的事件,传递SelectionKey.OP_ACCEPT(固定写法,用来监听客户端的请求事件)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo05Selector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    选择器Selector_服务器端实现多路注册</span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.创建3个ServerSocketChannel服务器对象</span></span><br><span class="line"><span class="comment">        2.为3个ServerSocketChannel服务器对象绑定不同的端口号</span></span><br><span class="line"><span class="comment">        3.设置3个ServerSocketChannel服务器对象为非阻塞模式(想要把服务器注册到选择器上必须为非阻塞的)</span></span><br><span class="line"><span class="comment">        4.创建Selector选择器对象</span></span><br><span class="line"><span class="comment">        5.使用3个ServerSocketChannel服务器对象中的方法register,把3个服务器注册在同一个选择器上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建3个ServerSocketChannel服务器对象</span></span><br><span class="line">        ServerSocketChannel channel01 = ServerSocketChannel.open();</span><br><span class="line">        ServerSocketChannel channel02 = ServerSocketChannel.open();</span><br><span class="line">        ServerSocketChannel channel03 = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.为3个ServerSocketChannel服务器对象绑定不同的端口号</span></span><br><span class="line">        channel01.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">7777</span>));</span><br><span class="line">        channel02.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        channel03.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">//3.设置3个ServerSocketChannel服务器对象为非阻塞模式(想要把服务器注册到选择器上必须为非阻塞的)</span></span><br><span class="line">        channel01.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        channel02.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        channel03.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//4.创建Selector选择器对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//5.使用3个ServerSocketChannel服务器对象中的方法register,把3个服务器注册在同一个选择器上</span></span><br><span class="line">        channel01.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        channel02.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        channel03.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-选择器Selector-常用方法"><a href="#3-选择器Selector-常用方法" class="headerlink" title="3.选择器Selector_常用方法"></a>3.选择器Selector_常用方法</h2><ul>
<li><strong>Selector的keys()方法</strong><ul>
<li>此方法返回一个Set<SelectionKey>集合，表示：已注册通道的集合。每个已注册通道封装为一个SelectionKey对象。</li>
</ul>
</li>
<li><strong>Selector的selectedKeys()方法</strong><ul>
<li>此方法返回一个Set<SelectionKey>集合，表示：当前已连接的通道的集合。每个已连接通道同一封装为一个SelectionKey对象。</li>
</ul>
</li>
<li><strong>Selector的select()方法</strong><ul>
<li>此方法会阻塞，直到至少有1个客户端连接。</li>
<li>此方法会返回一个int值，表示有几个客户端连接了服务器。</li>
</ul>
</li>
</ul>
<p><img src="img/1594870437329.png" alt="1594870437329"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo05Selector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    选择器Selector_服务器端实现多路注册</span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.创建3个ServerSocketChannel服务器对象</span></span><br><span class="line"><span class="comment">        2.为3个ServerSocketChannel服务器对象绑定不同的端口号</span></span><br><span class="line"><span class="comment">        3.设置3个ServerSocketChannel服务器对象为非阻塞模式(想要把服务器注册到选择器上必须为非阻塞的)</span></span><br><span class="line"><span class="comment">        4.创建Selector选择器对象</span></span><br><span class="line"><span class="comment">        5.使用3个ServerSocketChannel服务器对象中的方法register,把3个服务器注册在同一个选择器上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建3个ServerSocketChannel服务器对象</span></span><br><span class="line">        ServerSocketChannel channel01 = ServerSocketChannel.open();</span><br><span class="line">        ServerSocketChannel channel02 = ServerSocketChannel.open();</span><br><span class="line">        ServerSocketChannel channel03 = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.为3个ServerSocketChannel服务器对象绑定不同的端口号</span></span><br><span class="line">        channel01.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">7777</span>));</span><br><span class="line">        channel02.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        channel03.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">//3.设置3个ServerSocketChannel服务器对象为非阻塞模式(想要把服务器注册到选择器上必须为非阻塞的)</span></span><br><span class="line">        channel01.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        channel02.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        channel03.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//4.创建Selector选择器对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//5.使用3个ServerSocketChannel服务器对象中的方法register,把3个服务器注册在同一个选择器上</span></span><br><span class="line">        channel01.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        channel02.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        channel03.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Selector的keys()方法:已注册通道的集合</span></span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">        System.out.println(<span class="string">&quot;已注册通道的数量:&quot;</span>+keys.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个死循环,轮询监听客户端的请求</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//Selector的select()方法:表示(本次)有几个客户端连接了服务器,如果没有客户端连接服务器,此方法讲阻塞</span></span><br><span class="line">            <span class="keyword">int</span> select = selector.select();</span><br><span class="line">            System.out.println(<span class="string">&quot;本次连接服务器的客户端的数量为:&quot;</span>+select);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Selector的selectedKeys()方法:当前已连接的通道的集合</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            System.out.println(<span class="string">&quot;已经连接服务器的通道的数量为:&quot;</span>+selectionKeys.size());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;添加一个睡眠,睡眠2秒钟,再次获取客户端的请求...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo05Selector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建3个线程,每个线程访问服务器的一个端口号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//轮询连接服务器</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//创建客户端SocketChannel对象</span></span><br><span class="line">                    SocketChannel socket = SocketChannel.open();</span><br><span class="line">                    <span class="comment">//使用SocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line">                    <span class="keyword">boolean</span> b = socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接服务器7777端口成功,结束轮询...&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接服务器7777端口号失败,睡眠2秒钟,继续轮询连接服务器...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                        e1.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//轮询连接服务器</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//创建客户端SocketChannel对象</span></span><br><span class="line">                    SocketChannel socket = SocketChannel.open();</span><br><span class="line">                    <span class="comment">//使用SocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line">                    <span class="keyword">boolean</span> b = socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接服务器8888端口成功,结束轮询...&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接服务器8888端口号失败,睡眠2秒钟,继续轮询连接服务器...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                        e1.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//轮询连接服务器</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//创建客户端SocketChannel对象</span></span><br><span class="line">                    SocketChannel socket = SocketChannel.open();</span><br><span class="line">                    <span class="comment">//使用SocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line">                    <span class="keyword">boolean</span> b = socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接服务器9999端口成功,结束轮询...&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接服务器9999端口号失败,睡眠2秒钟,继续轮询连接服务器...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                        e1.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序执行结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">已注册通道的数量:<span class="number">3</span></span><br><span class="line">本次连接服务器的客户端的数量为:<span class="number">1</span></span><br><span class="line">已经连接服务器的通道的数量为:<span class="number">1</span></span><br><span class="line">添加一个睡眠,睡眠<span class="number">2</span>秒钟,再次获取客户端的请求...</span><br><span class="line">本次连接服务器的客户端的数量为:<span class="number">2</span></span><br><span class="line">已经连接服务器的通道的数量为:<span class="number">3</span></span><br><span class="line">添加一个睡眠,睡眠<span class="number">2</span>秒钟,再次获取客户端的请求...</span><br><span class="line">本次连接服务器的客户端的数量为:<span class="number">0</span></span><br><span class="line">已经连接服务器的通道的数量为:<span class="number">3</span></span><br><span class="line">添加一个睡眠,睡眠<span class="number">2</span>秒钟,再次获取客户端的请求...</span><br><span class="line">本次连接服务器的客户端的数量为:<span class="number">0</span></span><br><span class="line">已经连接服务器的通道的数量为:<span class="number">3</span></span><br><span class="line">添加一个睡眠,睡眠<span class="number">2</span>秒钟,再次获取客户端的请求...</span><br><span class="line">本次连接服务器的客户端的数量为:<span class="number">0</span></span><br><span class="line">已经连接服务器的通道的数量为:<span class="number">3</span></span><br><span class="line">添加一个睡眠,睡眠<span class="number">2</span>秒钟,再次获取客户端的请求...</span><br></pre></td></tr></table></figure>

<h2 id="4-选择器Selector-多路信息接收"><a href="#4-选择器Selector-多路信息接收" class="headerlink" title="4.选择器Selector_多路信息接收"></a>4.选择器Selector_多路信息接收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo06Selector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建3个线程,每个线程访问服务器的一个端口号</span></span><br><span class="line"><span class="comment">    每个客户端都给服务器发送数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//轮询连接服务器</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//创建客户端SocketChannel对象</span></span><br><span class="line">                    SocketChannel socket = SocketChannel.open();</span><br><span class="line">                    <span class="comment">//使用SocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line">                    <span class="keyword">boolean</span> b = socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接服务器7777端口成功,给服务器发送数据...&quot;</span>);</span><br><span class="line">                    socket.write(ByteBuffer.wrap(<span class="string">&quot;你好服务器,我是连接7777端口号的客户端!&quot;</span>.getBytes()));</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端给7777端口号发送数据完毕,结束轮询...&quot;</span>);</span><br><span class="line">                    <span class="comment">//释放资源</span></span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接服务器7777端口号失败,睡眠2秒钟,继续轮询连接服务器...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                        e1.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//轮询连接服务器</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//创建客户端SocketChannel对象</span></span><br><span class="line">                    SocketChannel socket = SocketChannel.open();</span><br><span class="line">                    <span class="comment">//使用SocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line">                    <span class="keyword">boolean</span> b = socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接服务器8888端口成功,给服务器发送数据...&quot;</span>);</span><br><span class="line">                    socket.write(ByteBuffer.wrap(<span class="string">&quot;你好服务器,我是连接8888端口号的客户端!&quot;</span>.getBytes()));</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端给8888端口号发送数据完毕,结束轮询...&quot;</span>);</span><br><span class="line">                    <span class="comment">//释放资源</span></span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接服务器8888端口号失败,睡眠2秒钟,继续轮询连接服务器...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                        e1.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//轮询连接服务器</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//创建客户端SocketChannel对象</span></span><br><span class="line">                    SocketChannel socket = SocketChannel.open();</span><br><span class="line">                    <span class="comment">//使用SocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line">                    <span class="keyword">boolean</span> b = socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接服务器9999端口成功,给服务器发送数据...&quot;</span>);</span><br><span class="line">                    socket.write(ByteBuffer.wrap(<span class="string">&quot;你好服务器,我是连接9999端口号的客户端!&quot;</span>.getBytes()));</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端给9999端口号发送数据完毕,结束轮询...&quot;</span>);</span><br><span class="line">                    <span class="comment">//释放资源</span></span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接服务器9999端口号失败,睡眠2秒钟,继续轮询连接服务器...&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                        e1.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo06Selector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    选择器Selector_服务器端实现多路注册</span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.创建3个ServerSocketChannel服务器对象</span></span><br><span class="line"><span class="comment">        2.为3个ServerSocketChannel服务器对象绑定不同的端口号</span></span><br><span class="line"><span class="comment">        3.设置3个ServerSocketChannel服务器对象为非阻塞模式(想要把服务器注册到选择器上必须为非阻塞的)</span></span><br><span class="line"><span class="comment">        4.创建Selector选择器对象</span></span><br><span class="line"><span class="comment">        5.使用3个ServerSocketChannel服务器对象中的方法register,把3个服务器注册在同一个选择器上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建3个ServerSocketChannel服务器对象</span></span><br><span class="line">        ServerSocketChannel channel01 = ServerSocketChannel.open();</span><br><span class="line">        ServerSocketChannel channel02 = ServerSocketChannel.open();</span><br><span class="line">        ServerSocketChannel channel03 = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.为3个ServerSocketChannel服务器对象绑定不同的端口号</span></span><br><span class="line">        channel01.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">7777</span>));</span><br><span class="line">        channel02.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">        channel03.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">//3.设置3个ServerSocketChannel服务器对象为非阻塞模式(想要把服务器注册到选择器上必须为非阻塞的)</span></span><br><span class="line">        channel01.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        channel02.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        channel03.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//4.创建Selector选择器对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//5.使用3个ServerSocketChannel服务器对象中的方法register,把3个服务器注册在同一个选择器上</span></span><br><span class="line">        channel01.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        channel02.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        channel03.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Selector的keys()方法:已注册通道的集合</span></span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">        System.out.println(<span class="string">&quot;已注册通道的数量:&quot;</span>+keys.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加一个死循环,轮询监听客户端的请求</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//Selector的select()方法:表示(本次)有几个客户端连接了服务器,如果没有客户端连接服务器,此方法讲阻塞</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器的select方法,等待客户端的连接...&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> select = selector.select();</span><br><span class="line">            System.out.println(<span class="string">&quot;本次连接服务器的客户端的数量为:&quot;</span>+select);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Selector的selectedKeys()方法:当前已连接的通道的集合</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            System.out.println(<span class="string">&quot;已经连接服务器的通道的数量为:&quot;</span>+selectionKeys.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历selectionKeys集合,获取每一个SelectionKey对象</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();/</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                SelectionKey selectionKey = it.next();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//取出SelectionKey中存储ServerSocketChannel对象</span></span><br><span class="line">                ServerSocketChannel channel = (ServerSocketChannel)selectionKey.channel();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用ServerSocketChannel对象,处理对象监听到ACCEPT事件(获取到请求服务器的客户端SocketChannel对象)</span></span><br><span class="line">                SocketChannel socketChannel = channel.accept();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用SocketChannel对象中的方法read,读取客户端发送的数据</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">int</span> len = socketChannel.read(buffer);</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器读取到客户端发送的数据:&quot;</span>+<span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>,len));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理完集合中对应的通道,就需要把通道在集合中删除了</span></span><br><span class="line">                it.remove();<span class="comment">//使用迭代器删除集合中元素的方法,不会抛出并发修改异常(移除的就是it.next方法取出的元素)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;睡眠2秒钟,再次获取客户端的请求...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">已注册通道的数量:<span class="number">3</span></span><br><span class="line">服务器的select方法,等待客户端的连接...</span><br><span class="line">本次连接服务器的客户端的数量为:<span class="number">1</span></span><br><span class="line">已经连接服务器的通道的数量为:<span class="number">1</span></span><br><span class="line">服务器读取到客户端发送的数据:你好服务器,我是连接<span class="number">8888</span>端口号的客户端!</span><br><span class="line">睡眠<span class="number">2</span>秒钟,再次获取客户端的请求...</span><br><span class="line">服务器的select方法,等待客户端的连接...</span><br><span class="line">本次连接服务器的客户端的数量为:<span class="number">2</span></span><br><span class="line">已经连接服务器的通道的数量为:<span class="number">2</span></span><br><span class="line">服务器读取到客户端发送的数据:你好服务器,我是连接<span class="number">9999</span>端口号的客户端!</span><br><span class="line">服务器读取到客户端发送的数据:你好服务器,我是连接<span class="number">7777</span>端口号的客户端!</span><br><span class="line">睡眠<span class="number">2</span>秒钟,再次获取客户端的请求...</span><br><span class="line">服务器的select方法,等待客户端的连接...</span><br><span class="line">本次连接服务器的客户端的数量为:<span class="number">1</span></span><br><span class="line">已经连接服务器的通道的数量为:<span class="number">1</span></span><br><span class="line">服务器读取到客户端发送的数据:你好服务器,我是连接<span class="number">7777</span>端口号的客户端!</span><br><span class="line">睡眠<span class="number">2</span>秒钟,再次获取客户端的请求...</span><br><span class="line">服务器的select方法,等待客户端的连接...</span><br><span class="line">本次连接服务器的客户端的数量为:<span class="number">2</span></span><br><span class="line">已经连接服务器的通道的数量为:<span class="number">2</span></span><br><span class="line">服务器读取到客户端发送的数据:你好服务器,我是连接<span class="number">9999</span>端口号的客户端!</span><br><span class="line">服务器读取到客户端发送的数据:你好服务器,我是连接<span class="number">8888</span>端口号的客户端!</span><br><span class="line">睡眠<span class="number">2</span>秒钟,再次获取客户端的请求...</span><br><span class="line">服务器的select方法,等待客户端的连接...</span><br></pre></td></tr></table></figure>

<h2 id="5-Selector执行的流程"><a href="#5-Selector执行的流程" class="headerlink" title="5.Selector执行的流程"></a>5.Selector执行的流程</h2><p><img src="img/1622447884036.png" alt="1622447884036"></p>
<h1 id="第五章-NIO2-AIO-异步、非阻塞"><a href="#第五章-NIO2-AIO-异步、非阻塞" class="headerlink" title="第五章 NIO2-AIO(异步、非阻塞)"></a>第五章 NIO2-AIO(异步、非阻塞)</h1><h2 id="1-AIO概述"><a href="#1-AIO概述" class="headerlink" title="1.AIO概述"></a>1.AIO概述</h2><p>​    JDK7新增的：AsynchronousIO：异步、非阻塞IO</p>
<h2 id="2-AIO异步非阻塞连接"><a href="#2-AIO异步非阻塞连接" class="headerlink" title="2.AIO异步非阻塞连接"></a>2.AIO异步非阻塞连接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">创建AIO的服务器端:</span><br><span class="line">    相关的类:</span><br><span class="line">        java.nio.channels.AsynchronousServerSocketChannel:用于面向流的侦听套接字的异步通道。</span><br><span class="line">    获取对的方法:</span><br><span class="line">        <span class="keyword">static</span> AsynchronousServerSocketChannel open​() 打开异步服务器套接字通道。</span><br><span class="line">    成员方法:</span><br><span class="line">        AsynchronousServerSocketChannel bind​(SocketAddress local) 给服务器绑定指定的端口号</span><br><span class="line">        <span class="keyword">void</span> accept​(A attachment, CompletionHandler&lt;?&gt; handler) 监听客户端的请求,默认就是非阻塞的</span><br><span class="line">        参数:</span><br><span class="line">            A attachment:附件,可以传递<span class="keyword">null</span></span><br><span class="line">            CompletionHandler&lt;?&gt; handler:事件处理的接口,用于处理accept方法监听到的事件</span><br><span class="line">            CompletionHandler:也叫回调函数,客户端请求服务器之后,会自动执行CompletionHandler接口中的方法</span><br><span class="line">     java.nio.channels.CompletionHandler&lt;V,A&gt;接口:用于消除异步I / O操作结果的处理程序。</span><br><span class="line">     接口中的方法:</span><br><span class="line">        <span class="keyword">void</span> completed​(V result, A attachment) 客户端连接服务器成功执行的方法</span><br><span class="line">        <span class="keyword">void</span> failed​(Throwable exc, A attachment) 客户端连接服务器失败执行的方法</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07AIOTCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建AIO的服务器端</span></span><br><span class="line"><span class="comment">        1.使用AsynchronousServerSocketChannel类中的方法open,获取异步非阻塞的服务器对象</span></span><br><span class="line"><span class="comment">        2.使用AsynchronousServerSocketChannel对象中的方法bind,绑定指定的端口号</span></span><br><span class="line"><span class="comment">        3.使用AsynchronousServerSocketChannel对象中的方法accpet,监听客户端的请求</span></span><br><span class="line"><span class="comment">        4.释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOTCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用AsynchronousServerSocketChannel类中的方法open,获取异步非阻塞的服务器对象</span></span><br><span class="line">        AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.使用AsynchronousServerSocketChannel对象中的方法bind,绑定指定的端口号</span></span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;accept方法开始执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">//3.使用AsynchronousServerSocketChannel对象中的方法accpet,监听客户端的请求</span></span><br><span class="line">        server.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端连接服务器成功,执行completed方法!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端连接服务器成功,执行failed方法!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;accept方法执行结束了...&quot;</span>);</span><br><span class="line">        <span class="comment">//accpet方法本身就是一个非阻塞的方法,不会一直等待客户端的请求</span></span><br><span class="line">        <span class="comment">//添加一个死循环,目的:不让程序结束(工作中:可以干一些有意义的事情)</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;休息2秒钟,干点其他的事情,等待客户端访问服务器!&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.释放资源(服务器不需要关闭)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建AIO的客户端:</span><br><span class="line">    相关的类:</span><br><span class="line">        java.nio.channels.AsynchronousSocketChannel:用于面向流的连接插座的异步通道。</span><br><span class="line">    获取对象的方法:</span><br><span class="line">        <span class="keyword">static</span> AsynchronousSocketChannel open​() 打开异步套接字通道。</span><br><span class="line">    成员方法:</span><br><span class="line">        Future&lt;Void&gt; connect​(SocketAddress remote) 连接服务器的方法,参数传递服务器的ip地址和端口号</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07AIOTCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建AIO的客户端</span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.使用AsynchronousSocketChannel类中的方法open,获取异步非阻塞的客户端对象</span></span><br><span class="line"><span class="comment">        2.使用AsynchronousSocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOTCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用AsynchronousSocketChannel类中的方法open,获取异步非阻塞的客户端对象</span></span><br><span class="line">        AsynchronousSocketChannel socket = AsynchronousSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.使用AsynchronousSocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line">        Future&lt;Void&gt; future = socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有客户端请求服务器,回调函数会自动执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">accept方法开始执行了...</span><br><span class="line">accept方法执行结束了...</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">客户端连接服务器成功,执行completed方法!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br></pre></td></tr></table></figure>

<h2 id="3-AIO异步连接-异步阻塞读写"><a href="#3-AIO异步连接-异步阻塞读写" class="headerlink" title="3. AIO异步连接:异步阻塞读写"></a>3. AIO异步连接:异步阻塞读写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AIO异步连接:异步阻塞读写</span><br><span class="line">   AsynchronousSocketChannel成员方法:</span><br><span class="line">       Future&lt;Integer&gt; write​(ByteBuffer src) 给服务器发送数据</span><br><span class="line">       Future&lt;Integer&gt; read​(ByteBuffer dst) 读取服务器发送的数据</span><br><span class="line">       Future&lt;Void&gt; connect​(SocketAddress remote) 连接服务器的方法,参数传递服务器的ip地址和端口号</span><br><span class="line">       java.util.concurrent.Future&lt;V&gt;接口</span><br><span class="line">           接口中的方法:</span><br><span class="line">           <span class="keyword">boolean</span> isDone​() 如果此任务完成，则返回 <span class="keyword">true</span> 。</span><br><span class="line">               返回<span class="keyword">true</span>:连接服务器成功</span><br><span class="line">               返回<span class="keyword">false</span>:还没有连接上服务器(客户端连接服务器是需要时间的)</span><br><span class="line">       注意:</span><br><span class="line">           connect​是一个非阻塞的方法,不会等待方法运行完毕,连接服务器成功在执行下边的代码</span><br><span class="line">           客户端连接服务器需要时间的,如果没有连接成功,就给服务器使用write方法发送数据,会抛出异常</span><br></pre></td></tr></table></figure>

<p>服务器读取客户端read方法:阻塞的会一直等待客户端发送数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo08AIOTCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建AIO的客户端</span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.使用AsynchronousSocketChannel类中的方法open,获取异步非阻塞的客户端对象</span></span><br><span class="line"><span class="comment">        2.使用AsynchronousSocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOTCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用AsynchronousSocketChannel类中的方法open,获取异步非阻塞的客户端对象</span></span><br><span class="line">        AsynchronousSocketChannel socket = AsynchronousSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.使用AsynchronousSocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line">        Future&lt;Void&gt; future = socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">        System.out.println(future.isDone());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//睡眠5秒钟,等待客户端连接服务器成功</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(future.isDone());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加一个判断,连接服务器成功,在发送数据</span></span><br><span class="line">        <span class="keyword">if</span>(future.isDone())&#123;</span><br><span class="line">            <span class="comment">//给服务器发送数据</span></span><br><span class="line">            socket.write(ByteBuffer.wrap(<span class="string">&quot;你好服务器&quot;</span>.getBytes()));</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo08AIOTCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建AIO的服务器端</span></span><br><span class="line"><span class="comment">        1.使用AsynchronousServerSocketChannel类中的方法open,获取异步非阻塞的服务器对象</span></span><br><span class="line"><span class="comment">        2.使用AsynchronousServerSocketChannel对象中的方法bind,绑定指定的端口号</span></span><br><span class="line"><span class="comment">        3.使用AsynchronousServerSocketChannel对象中的方法accpet,监听客户端的请求</span></span><br><span class="line"><span class="comment">        4.释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOTCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用AsynchronousServerSocketChannel类中的方法open,获取异步非阻塞的服务器对象</span></span><br><span class="line">        AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.使用AsynchronousServerSocketChannel对象中的方法bind,绑定指定的端口号</span></span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;accept方法开始执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">//3.使用AsynchronousServerSocketChannel对象中的方法accpet,监听客户端的请求</span></span><br><span class="line">        server.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端连接服务器成功,执行completed方法!&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器读取客户端发送的数据...&quot;</span>);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    Future&lt;Integer&gt; read​(ByteBuffer dst) 读取客户端发送的数据</span></span><br><span class="line"><span class="comment">                    read​方法:是一个阻塞的方法,客户端没有发送数据,则此方法一直等待客户端发送</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                Future&lt;Integer&gt; future = result.read(buffer);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    Future中的方法get:可以取出服务器读取到的数据</span></span><br><span class="line"><span class="comment">                    V get​() 等待计算完成，然后检索其结果。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Integer len = future.get();</span><br><span class="line">                    System.out.println(<span class="string">&quot;服务器读取到客户端发送的数据为:&quot;</span>+<span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>,len));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端连接服务器成功,执行failed方法!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;accept方法执行结束了...&quot;</span>);</span><br><span class="line">        <span class="comment">//accpet方法本身就是一个非阻塞的方法,不会一直等待客户端的请求</span></span><br><span class="line">        <span class="comment">//添加一个死循环,目的:不让程序结束(工作中:可以干一些有意义的事情)</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;休息2秒钟,干点其他的事情,等待客户端访问服务器!&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.释放资源(服务器不需要关闭)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">accept方法开始执行了...</span><br><span class="line">accept方法执行结束了...</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">客户端连接服务器成功,执行completed方法!</span><br><span class="line">服务器读取客户端发送的数据...</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">服务器读取到客户端发送的数据为:你好服务器</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br></pre></td></tr></table></figure>



<h2 id="4-AIO异步连接-异步非阻塞读写"><a href="#4-AIO异步连接-异步非阻塞读写" class="headerlink" title="4.AIO异步连接:异步非阻塞读写"></a>4.AIO异步连接:异步非阻塞读写</h2><p>服务器读取客户端read方法:可以设置等待客户端发送数据的时间,到时间之后,无论客户端是否发送数据,都会执行对应的方法,不在一直等待客户端了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo09AIOTCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建AIO的客户端</span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.使用AsynchronousSocketChannel类中的方法open,获取异步非阻塞的客户端对象</span></span><br><span class="line"><span class="comment">        2.使用AsynchronousSocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOTCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用AsynchronousSocketChannel类中的方法open,获取异步非阻塞的客户端对象</span></span><br><span class="line">        AsynchronousSocketChannel socket = AsynchronousSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.使用AsynchronousSocketChannel对象中的方法connect,根据服务器的ip地址和端口号连接服务器</span></span><br><span class="line">        Future&lt;Void&gt; future = socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">        System.out.println(future.isDone());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//睡眠5秒钟,等待客户端连接服务器成功</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(future.isDone());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加一个判断,连接服务器成功,在发送数据</span></span><br><span class="line">        <span class="keyword">if</span>(future.isDone())&#123;</span><br><span class="line">            <span class="comment">//给服务器发送数据</span></span><br><span class="line">            socket.write(ByteBuffer.wrap(<span class="string">&quot;你好服务器&quot;</span>.getBytes()));</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo09AIOTCP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建AIO的服务器端</span></span><br><span class="line"><span class="comment">        1.使用AsynchronousServerSocketChannel类中的方法open,获取异步非阻塞的服务器对象</span></span><br><span class="line"><span class="comment">        2.使用AsynchronousServerSocketChannel对象中的方法bind,绑定指定的端口号</span></span><br><span class="line"><span class="comment">        3.使用AsynchronousServerSocketChannel对象中的方法accpet,监听客户端的请求</span></span><br><span class="line"><span class="comment">        4.释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOTCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用AsynchronousServerSocketChannel类中的方法open,获取异步非阻塞的服务器对象</span></span><br><span class="line">        AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2.使用AsynchronousServerSocketChannel对象中的方法bind,绑定指定的端口号</span></span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;accept方法开始执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">//3.使用AsynchronousServerSocketChannel对象中的方法accpet,监听客户端的请求</span></span><br><span class="line">        server.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端连接服务器成功,执行completed方法!&quot;</span>);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    read​:是一个非阻塞的读取数据的方法,不会一直等待客户端了</span></span><br><span class="line"><span class="comment">                    void read​(ByteBuffer dst, long timeout, TimeUnit unit, A attachment, CompletionHandler&lt;Integer,? super A&gt; handler)</span></span><br><span class="line"><span class="comment">                        参数</span></span><br><span class="line"><span class="comment">                            ByteBuffer dst - 要传输字节的缓冲区</span></span><br><span class="line"><span class="comment">                            long timeout - 完成I / O操作的最长时间  10</span></span><br><span class="line"><span class="comment">                            TimeUnit unit - timeout参数的时间单位   TimeUnit.SECONDS:秒</span></span><br><span class="line"><span class="comment">                            A attachment - 要附加到I / O操作的对象; 可以是null</span></span><br><span class="line"><span class="comment">                            CompletionHandler handler - CompletionHandler也是一个回调函数</span></span><br><span class="line"><span class="comment">                                completed:在设置的有效时间内,客户端给服务器发送数据了,执行completed成功方法</span></span><br><span class="line"><span class="comment">                                failed:在设置的有效时间内,客户端没给服务器发送数据,执行failed失败方法</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                result.read(buffer, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;Integer, Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer len, Object attachment)</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;在设置的有效时间内,客户端给服务器发送数据了,执行completed成功方法&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;服务器读取客户端发送的数据...&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;服务器读取发送的数据为:&quot;</span>+<span class="keyword">new</span> String(buffer.array(),<span class="number">0</span>,len));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;在设置的有效时间内,客户端没给服务器发送数据,执行failed失败方法&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端连接服务器成功,执行failed方法!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;accept方法执行结束了...&quot;</span>);</span><br><span class="line">        <span class="comment">//accpet方法本身就是一个非阻塞的方法,不会一直等待客户端的请求</span></span><br><span class="line">        <span class="comment">//添加一个死循环,目的:不让程序结束(工作中:可以干一些有意义的事情)</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;休息2秒钟,干点其他的事情,等待客户端访问服务器!&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.释放资源(服务器不需要关闭)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取数据失败执行结果:10秒钟没有发数据,执行failed方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">accept方法开始执行了...</span><br><span class="line">accept方法执行结束了...</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">客户端连接服务器成功,执行completed方法!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">在设置的有效时间内,客户端没给服务器发送数据,执行failed失败方法</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息<span class="number">2</span>秒钟,干点其他的事情,等待客户端访问服务器!</span><br></pre></td></tr></table></figure>

<p>读取数据成功执行结果:10秒钟发送了数据,执行completed方法,读取数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">accept方法开始执行了...</span><br><span class="line">accept方法执行结束了...</span><br><span class="line">休息2秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息2秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">客户端连接服务器成功,执行completed方法!</span><br><span class="line">休息2秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息2秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息2秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">在设置的有效时间内,客户端给服务器发送数据了,执行completed成功方法</span><br><span class="line">服务器读取客户端发送的数据...</span><br><span class="line">服务器读取发送的数据为:你好服务器</span><br><span class="line">休息2秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息2秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息2秒钟,干点其他的事情,等待客户端访问服务器!</span><br><span class="line">休息2秒钟,干点其他的事情,等待客户端访问服务器!</span><br></pre></td></tr></table></figure>
	    <div>
			
				
<div>
    
        <div style="text-align:center;color: #555;font-size:24px;"><----------------------------------The End---------------------------------></div>
    
</div>

<div class="wechat_OA">
    <br>
	<h3 style="text-align: center">
	&emsp;欢迎扫一扫，订阅我的微信公众号！</h3>
    <!-- 这里添加你的二维码图片 -->
    <img src ="https://cdn.jsdelivr.net/gh/happy2h/PicPool_cdn/qrcode_for_gh_13e96145e8ee_344.jpg">
</div>
			
		</div>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>坚持原创分享，你的支持就是我最大的动力！</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/uploads/sanyecao.jpg" alt="LYF 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/uploads/sanyecao.jpg" alt="LYF 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://twitter.com/username">
          <span class="icon">
            <i class="fab fa-twitter"></i>
          </span>

          <span class="label">Twitter</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://t.me/channel_name">
          <span class="icon">
            <i class="fab fa-telegram"></i>
          </span>

          <span class="label">Telegram</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="/uploads/sanyecao.jpg">
          <span class="icon">
            <i class="fab fa-weixin"></i>
          </span>

          <span class="label">WeChat</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="/atom.xml">
          <span class="icon">
            <i class="fa fa-rss"></i>
          </span>

          <span class="label">RSS</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag"># 编程</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag"># Java基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2017/05/26/hello-world/" rel="prev" title="自学编程成功概率有多少可能">
                  <i class="fa fa-chevron-left"></i> 自学编程成功概率有多少可能
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LYF</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
